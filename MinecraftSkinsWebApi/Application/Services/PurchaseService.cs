// ---------------------------------------------------------------------
// AUTOGENERATED HEADER: Added by add_file_headers.ps1 at 2026-02-16 09:45:27
// File: MinecraftSkinsWebApi\Application\Services\PurchaseService.cs
// Purpose: Service for handling skin purchase operations
// ---------------------------------------------------------------------
// Application service: PurchaseService
// Responsibility:
// - Orchestrates the purchase flow: validate skin availability, compute price,
//   fetch BTC rate, create and persist Purchase entity.
// - Maps domain Purchase to PurchaseResponse DTO using AutoMapper.
// - Provides helper to check purchase ownership without exposing UserId in DTOs.

using Application.DTOs;
using Domain.Repositories;
using Application.Services.Interfaces;
using Domain.Models;
using AutoMapper;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Application.Services
{
    public class PurchaseService : IPurchaseService
    {
        private readonly IPurchaseRepository _purchaseRepository;
        private readonly ISkinRepository _skinRepository;
        private readonly IPriceCalculator _priceCalculator;
        private readonly IGetRateService _rateService;
        private readonly IMapper _mapper;
        private readonly ILogger<PurchaseService> _logger;

        public PurchaseService(
            IPurchaseRepository purchaseRepository,
            ISkinRepository skinRepository,
            IPriceCalculator priceCalculator,
            IGetRateService rateService,
            IMapper mapper,
            ILogger<PurchaseService> logger)
        {
            _purchaseRepository = purchaseRepository ?? throw new ArgumentNullException(nameof(purchaseRepository));
            _skinRepository = skinRepository ?? throw new ArgumentNullException(nameof(skinRepository));
            _priceCalculator = priceCalculator ?? throw new ArgumentNullException(nameof(priceCalculator));
            _rateService = rateService ?? throw new ArgumentNullException(nameof(rateService));
            _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Execute purchase flow for given user and skin. This method handles
        /// validation, price calculation and persistence. Throws ArgumentException
        /// if skin is not available.
        /// </summary>
        public async Task<PurchaseResponse> BuySkinAsync(string userId, int skinId, CancellationToken cancellationToken)
        {
            if (string.IsNullOrWhiteSpace(userId))
                throw new ArgumentException("UserId cannot be null or empty", nameof(userId));

            _logger.LogInformation("Processing purchase for user {UserId} and skin {SkinId}", userId, skinId);

            var skin = await _skinRepository.GetSkinByIdAsync(skinId, cancellationToken);
            if (skin == null)
                throw new ArgumentException($"Skin with id {skinId} not found", nameof(skinId));

            if (!skin.IsAvailable)
                throw new ArgumentException($"Skin with id {skinId} is not available for purchase", nameof(skinId));

            // Get BTC rate and compute final price
            var btcPrice = await _rateService.GetRateAsync(cancellationToken);
            var finalPrice = await _priceCalculator.CalculateFinalPriceAsync(skin.BasePriceUsd, cancellationToken);

            // Create domain entity and save
            var purchase = new Purchase(
                skinId: skin.Id,
                userId: userId,
                paidAmountUsd: finalPrice,
                btcPriceAtMonent: btcPrice,
                purchaseAt: DateTime.UtcNow);

            var saved = await _purchaseRepository.AddAsync(purchase, cancellationToken);

            _logger.LogInformation("Purchase completed successfully. Purchase ID: {PurchaseId}", saved.Id);

            // Map to DTO using AutoMapper (UserId automatically excluded)
            return _mapper.Map<PurchaseResponse>(saved);
        }

        /// <summary>
        /// Return purchases for the specified user.
        /// </summary>
        public async Task<IEnumerable<PurchaseResponse>> GetUserPurchasesAsync(string userId, CancellationToken cancellationToken)
        {
            if (string.IsNullOrWhiteSpace(userId))
                throw new ArgumentException("UserId cannot be null or empty", nameof(userId));

            var purchases = await _purchaseRepository.GetPurchasesByUserAsync(userId, cancellationToken);

            // Map collection using AutoMapper
            return _mapper.Map<IEnumerable<PurchaseResponse>>(purchases);
        }

        /// <summary>
        /// Get purchase by id. Returns DTO without user information.
        /// </summary>
        public async Task<PurchaseResponse?> GetPurchaseByIdAsync(int id, CancellationToken cancellationToken)
        {
            var purchase = await _purchaseRepository.GetPurchaseAsync(id, cancellationToken);
            if (purchase == null)
            {
                _logger.LogWarning("Purchase with id {PurchaseId} not found", id);
                return null;
            }

            // Map to DTO using AutoMapper
            return _mapper.Map<PurchaseResponse>(purchase);
        }

        /// <summary>
        /// Return owner's user id for a purchase (used by presentation layer to validate access).
        /// </summary>
        public async Task<string?> GetPurchaseOwnerIdAsync(int id, CancellationToken cancellationToken)
        {
            var purchase = await _purchaseRepository.GetPurchaseAsync(id, cancellationToken);
            return purchase?.UserId;
        }

        /// <summary>
        /// Check if a user owns a specific purchase
        /// </summary>
        public async Task<bool> UserOwnsPurchaseAsync(string userId, int purchaseId, CancellationToken cancellationToken)
        {
            if (string.IsNullOrWhiteSpace(userId))
                return false;

            var ownerId = await GetPurchaseOwnerIdAsync(purchaseId, cancellationToken);
            return ownerId == userId;
        }
    }
}